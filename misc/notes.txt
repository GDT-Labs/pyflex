benefits of pyflex:
1 - engineers don't need to worry about all the nerd knobs. Best practices are implemented everywhere
2 - documentation is simplified. We can create templates, and just insert values (elaborate)

need to establish dates for end of Sep, beginning of Oct. Click 2 Compute, Jim Gregory Trip, ACI deployment, and ODL forum.

    # functions_ucs would be an exmaple of a user-defined module. Someone that is savvy can write these functions in some kind of required way. 
    # If you want this to be a workflow engine, you have to focus on modularizing these functions and providing agnostic calls to them, with agnostic arguments.

You define your workflow in the main ucs script. Maybe break this workflow portion out as well?

        #TODO: this class is written from the perspective that you're building a UCS environment from scratch. Don't pidgeonhole yourself. 
        #For instance, you can't get a suborg object if it doesn't yet exist, but you also can't assume it doesn't.

    # Should leave these functions agnostic - meaning after you've gotten everything working, move all of the config into ucs.py, and leave these agnostic. You're relying on the state of this class a little too much. Consider this further.

Need to have a configuration validator. Unrealistic to be completely exhaustive, but the simple stuff like ensuring no VLAN overlap, similarly named templates, etc. should be good. Sort of indicates the need for a configuration importer unique to each infrastructure type. Ensure that there is only one VSAN per fabric, etc. Ensure that there is no VLAN that overlaps with teh VSAN IDs that you selected, in order to preserve FCoE VLAN IDs.


You are creating this tool to CREATE configurations....what about removing them? Maybe use the YAML file as an ongoing representation of the config, and use pyflex in the same way FB uses their tool. Maybe not.....hard to get engineers to stick with this. Initial config is one thing. Ongoing is another, especially for TSHOOT
--This is actually a good idea. But you'll need to find a way to search for objects that you don't know the name of. Maybe insert an asterisk in the DN string? Either way, there's some validity to creating each function to take a list of things, ensure they exist, and if they don't, create them. If others exist that are not defined in the config, delete them. There's some sexiness in being consistent like that
---UCS is going to be strange...things depend on other things. Nexus configuration is different - you can just re-apply new configurations each time you make a change? (figure that out)


See the validity of this:
handle.StartTransaction()
handle.CompleteTransaction()
(looks like this is only auto-generated by ConvertTo-UcsCmdlet when you're using a suborg to make changes. Maybe there's a reason for that)

Resource Pools: #Only creating a single block for everything, just to get stuff working. May consider coming back to allow for multiple pools/purposes, but not sure if anyone really uses that idea. (Actually this may even need to get simplified. I'm of the opinion that no one really uses the fancy formatting we do for MAC addresses)

Maybe consider using a "changed flag" similar to ansible


Tools like this turn EVERYTHING into a mentored install, and that's a good thing


Be sure that you replace all those generic UcsException handlers.....in defining a QoS policy, you ran into another error that was caught in error and you had to debug. Maybe use the ErrorCode?
UcsSdk.UcsBase.UcsException: [ErrorCode]: 106[ErrorDescription]: topRoot:  cannot contain: object of class epqosDefinition with RN ep-qos-Best-Effort, DN is ORG_TESTep-qos-Best-Effort
UcsSdk.UcsBase.UcsException: [ErrorCode]: 103[ErrorDescription]: Cannot create; object already exists.

This is less important from an initial configuration perspective, but as you're running your infrastructure, you may want to configure something like a Netapp array by using information from vSphere, for instance. Your model doesn't currently offer an easy to use mechanism for inter-component interaction like this. Ponder this.



        #TODO: Just copied and pasted this in: DO NOT FORGET TO IMPLEMENT THIS!!
        handle.AddManagedObject(obj, "storageLocalDiskConfigPolicy", {"Descr":"No Local Disk", "PolicyOwner":"local", "ProtectConfig":"yes", "Name":"NO_LOCAL", "Dn":"org-root/org-ORG_TEST/local-disk-config-NO_LOCAL", "Mode":"no-local-storage", "FlexFlashState":"disable", "FlexFlashRAIDReportingState":"disable"})
        handle.AddManagedObject(obj, "storageLocalDiskConfigPolicy", {"Descr":"Local Disk arranged in RAID 1", "PolicyOwner":"local", "ProtectConfig":"yes", "Name":"RAID1", "Dn":"org-root/org-ORG_TEST/local-disk-config-RAID1", "Mode":"raid-mirrored", "FlexFlashState":"disable", "FlexFlashRAIDReportingState":"disable"})

Just a brainstorm.....a workflow engine might work similarly to the UT/IT stuff in ODL. Adding classess to a list that extend a test class, with decorators, etc. Look into testing decorators


Fix QoS policy creation - BE is not being created

One big hurdle might be retrieving data from UCS...it's pretty easy with cmdlets right now, might not be as easy. Config data will be, but state data not so much

Need to properly classify traffic at the vNIC level....right now everything's being sent to Best Effort

Need to consider changes to existing policies. You've contemplated what it would take to delete things that aren't in the single source of truth, but what happens if the truth just changes? What happens if you update the targets on a BFS policy? how does pyflex know that a change has been made, to act accordingly by deleting this boot policy and recreate it? 